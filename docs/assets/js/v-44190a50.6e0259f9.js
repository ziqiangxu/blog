"use strict";(self.webpackChunkziqiangxu_github_io=self.webpackChunkziqiangxu_github_io||[]).push([[2533],{9651:(e,a,i)=>{i.r(a),i.d(a,{data:()=>t});const t={key:"v-44190a50",path:"/data-structure/%E9%80%92%E5%BD%92%E3%80%81%E9%80%92%E6%8E%A8%E5%92%8C%E5%9B%9E%E6%BA%AF.html",title:"递归、递推和回溯",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"一、递归",slug:"一、递归",children:[]},{level:2,title:"二、递推",slug:"二、递推",children:[]},{level:2,title:"三、回溯法",slug:"三、回溯法",children:[]}],filePathRelative:"data-structure/递归、递推和回溯.md",git:{updatedTime:162771849e4,contributors:[{name:"daryl",email:"ziqiang_xu@qq.com",commits:2},{name:"Daryl Xu",email:"ziqiang_xu@qq.com",commits:1},{name:"Daryl.Xu",email:"ziqiang_xu@yeah.net",commits:1}]}}},3765:(e,a,i)=>{i.r(a),i.d(a,{default:()=>d});const t=(0,i(6252).uE)('<h1 id="递归、递推和回溯" tabindex="-1"><a class="header-anchor" href="#递归、递推和回溯" aria-hidden="true">#</a> 递归、递推和回溯</h1><h2 id="一、递归" tabindex="-1"><a class="header-anchor" href="#一、递归" aria-hidden="true">#</a> 一、递归</h2><p><strong>递归可以利用前面计算的结果以求得答案。若一个对象部分地包含它自己，或用自己给自己定义，则这个对象是递归的；而且若一个过程直接或间接地调用自己，则称这个过程是递归的过程。</strong></p><ol><li>对于<strong>一个较复杂的问题，如果可以分解成几个相对简单的且解法相同的或类似的子问题</strong>时，只要解决这些子问题，那么原问题就迎刃而解了。</li></ol><blockquote><p>解决一个<code>i</code>的问题，就是解决<code>i - 1</code>的问题；解决<code>i -1</code>的问题，就是解决<code>i - 2</code>的问题，以此推到问题可以直接解决。</p></blockquote><ol start="2"><li><p>当分解之后的子问题可以直接解决时，就停止分解。这些可以直接解决的问题就是递归结束的条件。</p></li><li><p>递归定义的函数可以用递归过程来编程解决。递归过程直接反映了定义的结构</p></li></ol><p>数据结构是递归的： 如后面章节所讲到的广义表</p><h2 id="二、递推" tabindex="-1"><a class="header-anchor" href="#二、递推" aria-hidden="true">#</a> 二、递推</h2><p>递推是利用问题本身所具有的递推关系对问题求解的一种方法。采用递推法建立起来的算法一般具有重要的递推性质。我的理解就是可以由小规模推导出大规模，由小<code>i - 1</code>向大<code>i</code>推导。</p><blockquote><p>原文：即求得问题规模为<code>i - 1</code>的解之后，由问题的递推性质，能从已知求得的规模为<code>1, 2, ..., i -1</code>的一系列的解，构造出问题规模为<code>i</code>的解。<strong>和递归思路相反</strong></p></blockquote><h2 id="三、回溯法" tabindex="-1"><a class="header-anchor" href="#三、回溯法" aria-hidden="true">#</a> 三、回溯法</h2><p>回溯法也称为试探法，将问题的候选解按照某种顺序逐一枚举和检验。当发现当前候选解不可能是解时，就放弃它而选择下一个候选解。如果当前的解除了不满足问题规模外，其他所有要求都满足，则扩大当前候选解的规模继续试探。**放弃当前候选解，寻找下一个候选解的过程叫做回溯。**扩大当前候选解的规模，并继续试探的过程叫向前试探。</p>',12),d={render:function(e,a){return t}}}}]);