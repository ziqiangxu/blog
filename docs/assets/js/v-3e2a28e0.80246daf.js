"use strict";(self.webpackChunkziqiangxu_github_io=self.webpackChunkziqiangxu_github_io||[]).push([[717],{9827:(e,t,a)=>{a.r(t),a.d(t,{data:()=>n});const n={key:"v-3e2a28e0",path:"/data-structure/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%B2%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8.html",title:"第四章 数组、串与广义表",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"数组部分",slug:"数组部分",children:[]},{level:2,title:"串部分",slug:"串部分",children:[]},{level:2,title:"广义表",slug:"广义表",children:[]}],filePathRelative:"data-structure/第四章-数组、串与广义表.md",git:{updatedTime:1627719476e3,contributors:[{name:"Daryl Xu",email:"ziqiang_xu@qq.com",commits:1}]}}},124:(e,t,a)=>{a.r(t),a.d(t,{default:()=>s});const n=(0,a(6252).uE)('<h1 id="第四章-数组、串与广义表" tabindex="-1"><a class="header-anchor" href="#第四章-数组、串与广义表" aria-hidden="true">#</a> 第四章 数组、串与广义表</h1><h2 id="数组部分" tabindex="-1"><a class="header-anchor" href="#数组部分" aria-hidden="true">#</a> 数组部分</h2><blockquote><p>主要讲了普通数组的存储和特殊矩阵的压缩存储。</p></blockquote><ul><li>多维数组：二维数组可以用以一维数组为元素的一维数组表示，三维数组可以用二维数组和一维数组表示（一般是以行优先表示的）。</li><li>对称矩阵：a(i,j)等于a(j,i)，所以只需要存储大约一半的数据。</li><li>稀疏矩阵：因为矩阵内部大部分元素为0，所以只需要存储非零项就OK了，这样可以节省大量的空间，使用一个三元组结构体的数组存放非0项。</li></ul><div class="language-cpp ext-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>\n<span class="token keyword">struct</span> <span class="token class-name">Trituple</span><span class="token punctuation">{</span>\n    <span class="token keyword">int</span> row<span class="token punctuation">,</span> col<span class="token punctuation">;</span>   <span class="token comment">//存放元素在矩阵中的位置</span>\n    T value<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>关于稀疏矩阵的转置，也有很巧妙的解决办法。转置操作需要对元素进行重新排列：使用普通的循环即可完成排序工作，</p><blockquote><p>【一种优化方法：扫描所有的元素，使用两个辅助数组记录每行的元素数目和起始元素的列号。然后按照转置的定义重新排列元素】</p></blockquote><h2 id="串部分" tabindex="-1"><a class="header-anchor" href="#串部分" aria-hidden="true">#</a> 串部分</h2><p>主要是字符串</p><h2 id="广义表" tabindex="-1"><a class="header-anchor" href="#广义表" aria-hidden="true">#</a> 广义表</h2><p>广义表简称表，是线性表的推广，广义表中的元素可以是数据元素（原子）和子表。</p><p>广义表的定义是递归的，因为在表的描述中又用到了表，允许表中有表。 LS=(a0, a1, a2, ... )</p><p>表的表示方法，依然用到了结点的概念。用结点表示一个元素，这个结点分为3个部分：</p><table><thead><tr><th style="text-align:center;">标志域utype</th><th>信息域info</th><th style="text-align:center;">尾指针域tlink</th></tr></thead><tbody><tr><td style="text-align:center;">0</td><td>引用数ref</td><td style="text-align:center;">指向同层下一个结点</td></tr><tr><td style="text-align:center;">1</td><td>元素值value</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">2</td><td>子表的链接</td><td style="text-align:center;"></td></tr></tbody></table><p><code>utype=0</code> 时，该结点是附加头结点，ref记录了本表被引用——作为表元素的次数。 每一个子表都有一个附加头，这样做在删除一个表的第一个结点的时候会很方便。因为不用修改指向该表的指针，此时该表的地址用附加头的地址表示，删除任何一个结点都不会改变该表的地址。</p>',15),s={render:function(e,t){return n}}}}]);