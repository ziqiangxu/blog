"use strict";(self.webpackChunkziqiangxu_github_io=self.webpackChunkziqiangxu_github_io||[]).push([[5669],{6314:(e,t,d)=>{d.r(t),d.d(t,{data:()=>r});const r={key:"v-1f7def7e",path:"/network-secure/%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%88%B0%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3.html",title:"将本地端口转发到远程端口",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"扩展阅读",slug:"扩展阅读",children:[]}],filePathRelative:"network-secure/将本地端口转发到远程端口.md",git:{updatedTime:1601993027e3}}},591:(e,t,d)=>{d.r(t),d.d(t,{default:()=>i});var r=d(6252);const a=(0,r.uE)('<h1 id="将本地端口转发到远程端口" tabindex="-1"><a class="header-anchor" href="#将本地端口转发到远程端口" aria-hidden="true">#</a> 将本地端口转发到远程端口</h1><p>终端执行 <code>sudo ssh -L 443:127.0.0.1:8888 daryl@123.123.1.1</code></p><p>这条命令将本地443端口的请求转发到远程主机123.123.1.1的8888端口上</p><p>这在远程主机上使用 <code>jupyter notebook</code> 就很有用，这样你就不需要把服务器的 <code>8888</code> 端口暴露在公网上了。</p><hr><p>华丽的分割线</p><hr><p>还有一种带 <code>-i</code> 选项的用法 <code>sudo ssh -i &lt;一种pem后缀的验证文件，我没用过&gt; -L 443:127.0.0.1:8888 daryl@123.123.1.1</code></p><p>我记得这个 <code>pem</code> 文件是和 <code>SSL</code> 是有关系的</p><h2 id="扩展阅读" tabindex="-1"><a class="header-anchor" href="#扩展阅读" aria-hidden="true">#</a> 扩展阅读</h2>',10),n={href:"https://blog.csdn.net/fdipzone/article/details/79763632",target:"_blank",rel:"noopener noreferrer"},o=(0,r.Uk)("https://blog.csdn.net/fdipzone/article/details/79763632"),i={render:function(e,t){const d=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.j4)(r.HY,null,[a,(0,r.Wm)("p",null,[(0,r.Wm)("a",n,[o,(0,r.Wm)(d)])])],64)}}}}]);