import{_ as e,o as t,c as a,e as n}from"./app-e5af817a.js";const s={},l=n(`<h1 id="第四章-数组、串与广义表" tabindex="-1"><a class="header-anchor" href="#第四章-数组、串与广义表" aria-hidden="true">#</a> 第四章 数组、串与广义表</h1><h2 id="数组部分" tabindex="-1"><a class="header-anchor" href="#数组部分" aria-hidden="true">#</a> 数组部分</h2><blockquote><p>主要讲了普通数组的存储和特殊矩阵的压缩存储。</p></blockquote><ul><li>多维数组：二维数组可以用以一维数组为元素的一维数组表示，三维数组可以用二维数组和一维数组表示（一般是以行优先表示的）。</li><li>对称矩阵：a(i,j)等于a(j,i)，所以只需要存储大约一半的数据。</li><li>稀疏矩阵：因为矩阵内部大部分元素为0，所以只需要存储非零项就OK了，这样可以节省大量的空间，使用一个三元组结构体的数组存放非0项。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Trituple</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> row<span class="token punctuation">,</span> col<span class="token punctuation">;</span>   <span class="token comment">//存放元素在矩阵中的位置</span>
    T value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于稀疏矩阵的转置，也有很巧妙的解决办法。转置操作需要对元素进行重新排列：使用普通的循环即可完成排序工作，</p><blockquote><p>【一种优化方法：扫描所有的元素，使用两个辅助数组记录每行的元素数目和起始元素的列号。然后按照转置的定义重新排列元素】</p></blockquote><h2 id="串部分" tabindex="-1"><a class="header-anchor" href="#串部分" aria-hidden="true">#</a> 串部分</h2><p>主要是字符串</p><h2 id="广义表" tabindex="-1"><a class="header-anchor" href="#广义表" aria-hidden="true">#</a> 广义表</h2><p>广义表简称表，是线性表的推广，广义表中的元素可以是数据元素（原子）和子表。</p><p>广义表的定义是递归的，因为在表的描述中又用到了表，允许表中有表。 LS=(a0, a1, a2, ... )</p><p>表的表示方法，依然用到了结点的概念。用结点表示一个元素，这个结点分为3个部分：</p><table><thead><tr><th style="text-align:center;">标志域utype</th><th>信息域info</th><th style="text-align:center;">尾指针域tlink</th></tr></thead><tbody><tr><td style="text-align:center;">0</td><td>引用数ref</td><td style="text-align:center;">指向同层下一个结点</td></tr><tr><td style="text-align:center;">1</td><td>元素值value</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">2</td><td>子表的链接</td><td style="text-align:center;"></td></tr></tbody></table><p><code>utype=0</code> 时，该结点是附加头结点，ref记录了本表被引用——作为表元素的次数。 每一个子表都有一个附加头，这样做在删除一个表的第一个结点的时候会很方便。因为不用修改指向该表的指针，此时该表的地址用附加头的地址表示，删除任何一个结点都不会改变该表的地址。</p>`,15),c=[l];function d(i,r){return t(),a("div",null,c)}const o=e(s,[["render",d],["__file","第四章-数组、串与广义表.html.vue"]]);export{o as default};
