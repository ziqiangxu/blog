import{_ as o,o as e,c,e as d}from"./app-c2d3a443.js";const t={},r=d('<h1 id="关闭-chrome-的安全策略-可用于跨域" tabindex="-1"><a class="header-anchor" href="#关闭-chrome-的安全策略-可用于跨域" aria-hidden="true">#</a> 关闭 <code>chrome</code> 的安全策略：可用于跨域</h1><p>对于 <code>Linux</code>，终端执行: <code>google-chrome --disable-web-security --user-data-dir=&lt;path to store the data&gt;</code>。</p><blockquote><p>如 <code>google-chrome --disable-web-security --user-data-dir=/home/xu/test-dir</code></p></blockquote><ul><li>其中 <code>--disable-web-security</code> 选项关闭 <code>web</code> 的一些安全策略【其中包括阻止不合法的跨域请求】。</li><li>在 <code>Linux</code> 下，如果要关闭安全策略，则必须指定一个目录 <code>user-data-dir</code> 用于保存这样运行浏览器所产生的一些数据</li></ul><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h2><p>前后端分离开发时</p><ul><li>前端运行在 <code>http://localhost:8080</code></li><li>后端运行在 <code>http://localhost:8000</code></li></ul><p>这时前端对后端发起请求属于跨域了（只要协议、域名、端口有任何一个的不同，就被当作是跨域——不同<strong>域</strong>），正式上线网站的时候一般都会把前后端放到一个<strong>域</strong>里，比如将前端打包成静态资源后使用 <code>nginx</code> 进行部署或者直接由和后台代码放在一起。</p><h2 id="限制跨域访问是浏览器的安全策略-主要有两种" tabindex="-1"><a class="header-anchor" href="#限制跨域访问是浏览器的安全策略-主要有两种" aria-hidden="true">#</a> 限制跨域访问是浏览器的安全策略，主要有两种：</h2><ul><li><code>DOM</code> 同源策略：禁止对不同源页面 <code>DOM</code> 进行操作。这里主要场景是 <code>iframe</code> 跨域的情况，不同<strong>域</strong>的 <code>iframe</code> 是限制互相访问的。</li><li><code>XMLHttpRequest</code> 同源策略：禁止使用 <code>XHR</code> 对象向不同<strong>域</strong>发起 <code>HTTP</code> 请求。</li></ul><h2 id="为什么浏览器要这样做" tabindex="-1"><a class="header-anchor" href="#为什么浏览器要这样做" aria-hidden="true">#</a> 为什么浏览器要这样做？</h2><p>当然是为了安全啊</p><p>我们假设有两个<strong>域</strong>:</p><ul><li><strong>域</strong>1：存着你血汗钱的网站： <code>http://money.com</code></li><li><strong>域</strong>：一个恶意网站： <code>http://坏人.com</code></li></ul><p>为了方便在客户端存储少量信息，浏览器推出了 <code>cookie</code> 这样的功能。</p><blockquote><p>即浏览器每次发起 <code>http</code> 请求，浏览器都会自动带上这个<strong>域</strong>的 <code>cookie</code>， 比如访问 <code>http://money.com</code> 的主页，浏览器则会自动帮你带上 <code>http://money.com</code> 这个<strong>域</strong>的 <code>cookie</code></p></blockquote><p>这样可以很方便的使得 <code>http://money.com</code> 的后台程序根据 <code>cookie</code> 所携带的信息来改善用户的使用体验，最常用的就是以此来识别用户，使用户保持登录状态。但是这样有一个副作用：</p><blockquote><p>即使你是在其它<strong>域</strong>通过 <code>XMLHttpRequest</code> 对象发起这个 <code>http</code> 请求，也同样是带上 <code>money.com</code> 这个<strong>域</strong>的 <code>cookie</code>。这就给坏人带来了机会</p></blockquote><p><strong>试想这样一个场景</strong>:</p><p>你刚登录了 <code>http://money.com</code> 这个网站，验证信息保存在 <code>cookie</code> 里，而且还没有过期。然后你又进入了 <code>http://坏人.com</code> 这个网站，坏人网站载入的时候就在后台用 <code>XMLHttpRequest</code> 对象向 <code>http://money.com</code> 发请求。如果浏览器不管不顾，直接就允许了，那这个请求就带着 <code>cookie</code> 发出去了，服务端一看 <code>cookie</code> 里的验证信息，是 <code>OK</code> 的。坏人不就得到服务器返回的信息了么，然后他就拿着你的信息做坏事了，好可怕。</p><p>实际上呢，以 <code>google-chrome</code> 为例（<code>google-chrome</code> 默认打开了相关的安全策略）：</p><ol><li>如果服务端允许任何其它域来请求：则允许这个请求，然后坏人就得逞了。</li><li>如果服务端只允许指定的域来请求：发现这个请求来自于<code>http://坏人.com</code> 域，不在设定的许可名单里，则不会允许这个陌生的请求</li></ol><blockquote><p>当我们关闭了 <code>google-chrome</code> 的安全策略的时候，这个请求直接就发出去了，根本不管服务端允许不允许的。这是怎么实现的呢，请求里不带发送域或者是直接将发送域替换成目的域吗？</p></blockquote>',23),i=[r];function l(s,n){return e(),c("div",null,i)}const h=o(t,[["render",l],["__file","关闭chrome的安全策略.html.vue"]]);export{h as default};
